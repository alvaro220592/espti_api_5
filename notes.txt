definir banco de dados ŕa utf8mb4_unicode_ci

limitar o nº de caracteres do email da tabela users

criar model Models\\Product com -m

definiir o $fillable

editar a migration

dar migrate

criar seeder de usuario: php artisan make:seeder UsersTableSeeder

criar seeder de produtos: php artisan make:seeder ProductsTableSeeder

O usuario var ser criado na seeder. A senha nao foi configurada com hash e sim : "'password' => bcrypt('12345678'),"

Produtos foram cadastrados por factory: php artisan make:factory Productfactory --model=Product
    dentro da factory:
        $factory->define(App\Models\Product::class, function (Faker $faker) {
            return [
                'name' => $faker->unique()->word(),
                'description' => $faker->sentence()
            ];
        });

Na seeder de produtos, foi chamada a factory:
    public function run()
    {
        factory(App\Models\Product::class, 20)->create();
    }

na DatabaseSeeder, vão ser chamados os seeders de usuário e produtos:
    $this->call(UsersTableSeeder::class);
    $this->call(ProductsTableSeeder::class);

Pra rodar:
    php artisan db:seed


aula 5: criação da api
    As rotas serão versionadas e do tipo resource
    Foi criado o controller de produtos dentro de uma pasta "Api" com as flags --api e --model=Models\\Product

    no controller foi instanciada a model Product no construtor pra nao precisar instanciar em todos os métodos:

    private $product;
    
    public function __construct(Product $product)
    {   
        $this->product = $product;
    }

    daí pra frente, sempre se refere a ela como "$this->product"

aula 7 - cadastrar e validar:
    
    model Product:
    public function rules($id = ''){
        return [
            'name' => "required|min:3|max:100|unique:products,name,{$id},id",
            'description' => 'required|min:10|max:1000'
        ];
    }

    Controller:

    public function store(Request $request)
    {
        $validate = validator($request->all(), $this->product->rules());

        if($validate->fails()){
            return response()->json($validate->messages());
        }

        if (! $this->product->create($request->all()))
            return response()->json(['Erro' => 'Erro ao cadastrar'], 500);
        
        return response()->json([
            'Mensagem' => 'Cadastro realizado com sucesso',
            'Dados' => $request->all()
        ]);
    }

aula 8 - exibir produto
    método show:
    public function show($id)
    {
        if(! $this->product = Product::find($id))
            return response()->json(['Mensagem' => 'Produto não encontrado']);
        return response()->json(['Produtos' => $this->product]);
    }

aula 9 - alterar e validar
    Controller:
    public function update(Request $request, $id)
    {
        $product = $this->product->find($id);

        // verificando se existe o produto com o id informado
        if(! $product)
            return response()->json(['Mensagem' => 'Produto não encontrado']);

        $validacao = validator($request->all(), $product->rules($id));

        if($validacao->fails())
            return response()->json(['Erro' => $validacao->messages()]);

        if(! $product->update($request->all()))
            return response()->json(['Erro' => 'Erro ao alterar'], 500);
        return response()->json([
            'Mensagem' => 'Dados alterados com sucesso',
            'Produto' => $product
        ]);
    }

aula 10 - deletando:
    public function destroy($id)
    {
        if (! $produto = $this->product->find($id))
            return response()->json(['Mensagem' => 'Produto não encontrado']);

        if (! $produto->delete())
            return response()->json(['Erro' => 'Erro ao excluir']);
        return response()->json([
            'Mensagem' => 'Produto excluído com sucesso',
            'Produto' => $produto
        ]);
    }

aula 11- versionamento de api - já está versionada desde o começo

aula 12 - limite de requisições
    em app/http/kernel tem uma parte chamada 'api' que tem o throttle, onde consta o  numero de requisições e o numero em minutos. Tantas requisições por minuto

aula 13 - paginar e pesquisar.
    A paginação já foi feita. Falta o search
    foi criada uma rota e um método pra search

    model:
        public function ruleSearch(){
            return [
                'busca' => 'required'
            ];
        }

        public function search($data){

            return $this->where('name', 'like', "%{$data['busca']}%")
                        ->orWhere('description', 'like', "%{$data['busca']}%")
                        ->paginate(10);
        }

    Controller:
        public function search(Request $request){
        $data = $request->all();

        $validacao = validator($data, $this->product->ruleSearch());
        if ($validacao->fails())
            return response()->json(['Erro' => $validacao->messages()]);
        
        return response()->json(['Resultado' => $this->product->search($data)]);
    }
